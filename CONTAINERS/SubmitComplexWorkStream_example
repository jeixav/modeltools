#!/bin/bash
#
# all arguments will be passed to ord_soumet
# called with  
#    -t ${walltime} -mpi -cpus ${cpus}x1 -jn ${name} -shell nologin ${QuEuE} "$@"
#    walltime, cpus, name, QuEuE : from user adjusted section
#
unset QUEUE_1CPU
unset QUEUE_2CPU
unset QUEUE_3CPU
unset QUEUE_4CPU
#
export ContainerJob=${TMPDIR}/ContainerJob_$$
export VERSION=1.0
#
export RunWorkStream=$(readlink -e $(which run_work_stream_${VERSION}) 2>/dev/null)
if [[ -z ${RunWorkStream} ]] ; then
  echo "FATAL: run_work_stream_${VERSION} not found, ABORTING"
  exit 1
fi
export PickAndRunWork=$(readlink -e $(which pick_and_run_work_${VERSION}) 2>/dev/null)
if [[ -z ${PickAndRunWork} ]] ; then
  echo "FATAL: pick_and_run_work_${VERSION} not found, ABORTING"
  exit 1
fi
#===============================================================================
#                    START of section to be adjusted by user                   #
#===============================================================================
# example using 16 cores (2 nodes with 8 cores each)
#
walltime=600             # wall clock time for container
cpus=16                  # number of cores needed by container
QuEuE=""                 # queue to submit to
name="InputAndModel"     # job name for container
nodesize=8               # number of cores per node
cat <<\EOJ >${ContainerJob}.user
#
#------------------------------------------------------------------------------------------------------------------------------
# launch 1 x 12 way queue, 1 thread per process
#------------------------------------------------------------------------------------------------------------------------------
export maxidle=60
name=micro12 ; queues="${name}" ; BATCH_MPI_CPUS=12 ; export OMP_NUM_THREADS=1 ;   # 12 processes with 1 thread  = 12 cores
instanciate 0:4-7 1:0-7      # node 0 cpus 4-7, node 1 cpus 0-7
#------------------------------------------------------------------------------------------------------------------------------
# launch 2 x 1 way queues
#------------------------------------------------------------------------------------------------------------------------------
export maxidle=${walltime}
# first queue called micro1
name=micro1 ; queues="${name} ${name}-1" ; BATCH_MPI_CPUS=1 ; export OMP_NUM_THREADS=2         # 2 cores per instance = 2 cores
instanciate 0:0-1           # node 0, cpu 0-1
# second queue called micro2
name=micro2 ; queues="${name} ${name}-1" ; BATCH_MPI_CPUS=1 ; export OMP_NUM_THREADS=2         # 2 cores per instance = 2 cores
instanciate 0:2-3           # node 0, cpu 2-3
EOJ
#===============================================================================
#                     END of section to be adjusted by user                    #
#===============================================================================
#
cat <<EOJ >${ContainerJob}
export RunWorkStream=${RunWorkStream}
export PickAndRunWork=${PickAndRunWork}
export walltime=${walltime}
export nodesize=${nodesize}
EOJ
#
cat <<\EOJ >>${ContainerJob}
#
# get list of processes for which a taskset will have to be applied
#
export MyProcesses=""
for i in $(pgrep -u $USER) ; do 
  kill -s 0 $i && MyProcesses="$MyProcesses $i"
done
echo "=== MY PROCESSES : $MyProcesses ==="
echo "=== NODE FILE ==="
cat $PBS_NODEFILE
export SAVE_HOSTFILE=$PBS_NODEFILE
export NODEFILE_PBS=${PBS_NODEFILE}
export RANKFILE_PBS
#
# arguments    noderange:cpurange ... noderange:cpurange
# noderange    node | firstnode-lastnode               (origin 0)
# cpurange     cpu  | firstcpu-lastcpu                 (origin 0)
#    0:2-5     Node 0, cpus 2 thru 5 
#    1-4:0-15  Nodes 1 thru 4, cpus 0 thru 15
make_map()   #  build OpenMPI rank file for this instance
{
((rank=0))
incr=${OMP_NUM_THREADS:-1}
ntiles=${BATCH_MPI_CPUS:-1}
while [[ -n $1 ]] ; do
  arg="$1"
  [[ "$arg" == *:* ]] || arg="$arg:"                     # no cpu range, add trailing :
  [[ "$arg" == *: ]] && arg="${arg}0-$((nodesize-1))"    # replace missing cpu range by all cpus on a node
  nodes="${arg%:*}"
  cpus="${arg#*:}"
  [[ "$nodes" == *-* ]] || nodes="${nodes}-${nodes}"     # transform node number into node range
  [[ "$cpus" == *-* ]] || cpus="${cpus}-${cpus}"         # transform cpu number into cpu range
  shift
  for n in $(seq $(echo ${nodes}| tr -- '-' " ") ) ; do  # build OpenMPI rank file
   low=${cpus%-*}
   high=${cpus#*-}
   while ((low+incr<=high+1 && rank<ntiles)) ; do
     ((incr==1)) && echo "rank $rank=+n$n slot=${low}"
     ((incr>1))  && echo "rank $rank=+n$n slot=${low}-$((low+incr-1))"
     ((low=low+incr))
     ((rank=rank+1))
   done
  done
done
}
#
instanciate() # create one sub-container. arguments will be passed verbatim to make_map
{
  Arg1="${1}"
  RANKFILE_PBS=${NodeFileDir}/${name}-${instance}
  echo "======================================================================================" >>${ListingFile}+${name}-${instance}
  chmod 644 ${ListingFile}+${name}-${instance}
  make_map $* >${RANKFILE_PBS}                                      # create OpenMPI rank file
  cat ${RANKFILE_PBS} >>${ListingFile}+${name}-${instance}          # write rank file into listing file
  echo "======================================================================================" >>${ListingFile}+${name}-${instance}
  HostTaskset=0-$((nodesize-1))                                     # default taskset for node 0 is all cpus on node
  [[ "${Arg1}" == 0:* ]] && HostTaskset=${Arg1#0:}                  # if a taskset has been specified for node 0, use it
  export HostTaskset
  for p in ${MyProcesses} ; do taskset -cp $HostTaskset $p ; done   # run only on prescribed taskset (node 0 only)
#
# start sub-container with node 0 taskset constraints
#
  ${RunWorkStream} -name ${name}-${instance} -maxidle $maxidle -queues $queues     \
       2>>${ListingFile}+${name}-${instance} 1>>${ListingFile}+${name}-${instance} &
#
  for p in ${MyProcesses} ; do 
    taskset -cp 0-$((nodesize-1)) $p ;            # cancel taskset restrictions
  done
  ((instance=instance+1))                         # bump instance count
}
#------------------------------------------------------------------------------------------------------------------------------
mkdir -p ${HOME}/.job_queues/nodefiledir
export NodeFileDir="${HOME}/.job_queues/nodefiledir/$(hostname)$(date +%s)"
export InstanceQuitFile=${NodeFileDir}/InstanceQuitFile      # quit signal from first sub-container that terminates
mkdir ${NodeFileDir} || exit 1
touch ${InstanceQuitFile} || exit 1
export TODO_UPON_EXIT='rm -rf ${NodeFileDir} ; kill -9 $$'
#
echo $(hostname) >${NodeFileDir}/nodes.master
cat ${PBS_NODEFILE} | grep -v "^$(hostname)" | uniq >>${NodeFileDir}/nodes.master
LocalHost="$(hostname)"
#
export instance=0
export NODEFILE_PBS=${NodeFileDir}/nodes.master
export FORCE_SETUP=yes
export name=""
export queues=""
EOJ
cat ${ContainerJob}.user >>${ContainerJob}
rm -f ${ContainerJob}.user
cat <<\EOJ >>${ContainerJob}
#------------------------------------------------------------------------------------------------------------------------------
wait   # wait for backgrounded sub-containers to terminate
#------------------------------------------------------------------------------------------------------------------------------
rm -f ${InstanceQuitFile}  # global quit signal file
rm -f ${NodeFileDir}/*     # remove node files
rmdir ${NodeFileDir}       # directory should now be empty, remove it
EOJ
cat ${ContainerJob}
echo "ord_soumet ${ContainerJob} -t ${walltime} -mpi -cpus ${cpus}x1 -jn ${name} -shell nologin ${QuEuE} $@"
#ord_soumet ${ContainerJob} -t ${walltime} -mpi -cpus ${cpus}x1 -jn ${name} -shell nologin ${QuEuE} "$@"
rm -f ${ContainerJob}
