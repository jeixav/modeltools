#!/bin/bash
echo This version kept for historical reference, it is no longer used
exit 1
usage() {
cat <<EOT
  usage: ${0##*/} -wall n_seconds -cpus n_cpus -nodesize n_cores -queue q_name -name job_name [-submit] -cfg config_file
EOT
exit 0
}
[[ "$1" == -h || "$1" == --help ]] && usage
#===============================================================================
#                    start of section to be adjusted by user                   #
#===============================================================================
#
# example using 24 cores (2 nodes with 12 cores each)
#
wall=600             # wall clock time for container
cpus=24                  # number of cores needed by container
nodesize=12
queue="12"                 # queue to submit to
name="AtmOceCoupled"     # job name for container
submit=""
cfg=""
#===============================================================================
#                     end of section to be adjusted by user                    #
#===============================================================================
#
[[ -n ${queue} ]] && queue="-q ${queue}"
#
unset QUEUE_1CPU
unset QUEUE_2CPU
unset QUEUE_3CPU
unset QUEUE_4CPU
#
ContainerJob=${TMPDIR}/ContainerJob_$$
VERSION=1.0
which run_work_stream_${VERSION} >/dev/null   || { echo "ERROR: run_work_stream_${VERSION} not found, ABORTING" 1>&2; exit 1 ; }
which pick_and_run_work_${VERSION} >/dev/null || { echo "ERROR: pick_and_run_work_${VERSION} not found, ABORTING"  1>&2; exit 1 ; }
#
cat <<EOJ >${ContainerJob}
export RunWorkStream="$(which run_work_stream_${VERSION})"
export PickAndRunWork="$(which pick_and_run_work_${VERSION})"
wall=${wall}
nodesize=${nodesize}
EOJ
#
cat <<\EOJ >>${ContainerJob}
#
# get list of processes for which a taskset will have to be applied
#
export MyProcesses=""
for i in $(pgrep -u $USER) ; do kill -s 0 $i && MyProcesses="$MyProcesses $i" ; done
echo === $MyProcesses ===
cat $PBS_NODEFILE
export SAVE_HOSTFILE=$PBS_NODEFILE
export NODEFILE_PBS=${PBS_NODEFILE}
export RANKFILE_PBS
#
# arguments    noderange:cpurange ... noderange:cpurange
# noderange    node | firstnode-lastnode               (origin 0)
# cpurange     cpu  | firstcpu-lastcpu                 (origin 0)
make_map()   #  build OpenMPI rank file for this instance
{
((rank=0))
incr=${OMP_NUM_THREADS:-1}
ntiles=${BATCH_MPI_CPUS:-1}
while [[ -n $1 ]] ; do
  arg="$1"
  [[ "$arg" == *:* ]] || arg="$arg:"                     # no cpu range, add trailing :
  [[ "$arg" == *: ]] && arg="${arg}0-$((nodesize-1))"    # replace missing cpu range by all cpus on a node
  nodes="${arg%:*}"
  cpus="${arg#*:}"
  [[ "$nodes" == *-* ]] || nodes="${nodes}-${nodes}"     # transform node number into node range
  [[ "$cpus" == *-* ]] || cpus="${cpus}-${cpus}"         # transform cpu number into cpu range
  shift
  for n in $(seq $(echo ${nodes}| tr -- '-' " ") ) ; do  # build OpenMPI rank file
   low=${cpus%-*}
   high=${cpus#*-}
   while ((low+incr<=high+1 && rank<ntiles)) ; do
     ((incr==1)) && echo "rank $rank=+n$n slot=${low}"
     ((incr>1))  && echo "rank $rank=+n$n slot=${low}-$((low+incr-1))"
     ((low=low+incr))
     ((rank=rank+1))
   done
  done
done
}
#
instanciate() # create one sub-container. arguments will be passed verbatim to make_map
{
  Arg1="${1}"
# NODEFILE_PBS=${NodeFileDir}/${name}-${instance}
  RANKFILE_PBS=${NodeFileDir}/${name}-${instance}
# rm -f ${NODEFILE_PBS}
# ((nlocal>0)) && echo ${LocalHost} slots=${nlocal} >>${NODEFILE_PBS}
# ((first>0)) && cat ${NodeFileDir}/nodes.master | sed "s/$/ slots=$((nodesize/OMP_NUM_THREADS))/" | sed -n ${first},${last}p >>${NODEFILE_PBS}
  echo "======================================================================================" >>${ListingFile}+${name}-${instance}
  chmod 644 ${ListingFile}+${name}-${instance}
# cat ${NODEFILE_PBS} >>${ListingFile}+${name}-${instance}
  make_map $* >${RANKFILE_PBS}
  cat ${RANKFILE_PBS} >>${ListingFile}+${name}-${instance}
  echo "======================================================================================" >>${ListingFile}+${name}-${instance}
  HostTaskset=0-$((nodesize-1))                                  # default taskset for node 0
  [[ "${Arg1}" == 0:* ]] && HostTaskset=${Arg1#0:}    # if a taskset has been specified for node 0, use it
  export HostTaskset
  for p in ${MyProcesses} ; do taskset -cp $HostTaskset $p ; done   # run only on prescribed taskset (node 0 only)
  ${RunWorkStream:-${HOME}/ECssm/multi/bin/run_work_stream} -name ${name}-${instance} -maxidle $maxidle \
       -queues $queues 2>>${ListingFile}+${name}-${instance} 1>>${ListingFile}+${name}-${instance} &
  for p in ${MyProcesses} ; do taskset -cp 0-$((nodesize-1)) $p ; done           # run on any cpu
# NODEFILE_PBS=${SAVE_HOSTFILE}
  ((instance=instance+1))
}
#------------------------------------------------------------------------------------------------------------------------------
mkdir -p ${HOME}/.job_queues/nodefiledir
export NodeFileDir="${HOME}/.job_queues/nodefiledir/$(hostname)$(date +%s)"
export InstanceQuitFile=${NodeFileDir}/InstanceQuitFile      # quit signal from first sub-container that terminates
mkdir ${NodeFileDir} || exit 1
touch ${InstanceQuitFile} || exit 1
export TODO_UPON_EXIT='rm -rf ${NodeFileDir} ; kill -9 $$'
#
echo $(hostname) >${NodeFileDir}/nodes.master
cat ${PBS_NODEFILE} | grep -v "^$(hostname)" | uniq >>${NodeFileDir}/nodes.master
LocalHost="$(hostname)"
#
export instance=0
export NODEFILE_PBS=${NodeFileDir}/nodes.master
export FORCE_SETUP=yes
export name=""
export queues=""
EOJ
[[ -z ${cfg} ]] && cfg=${0%/*}/demo_container.cfg && submit="" && echo "INFO: demo mode" 1>&2
echo "INFO: using configuration file '${cfg}'" 1>&2
if [[ -r ${cfg} ]] ; then          # user supplied or demo config file
  cat ${cfg} >>${ContainerJob}
else
  echo "ERROR: no config file specified, ABORTING" 1>&2
  rm -f ${ContainerJob}
  exit 1
fi
cat <<\EOJ >>${ContainerJob}
#------------------------------------------------------------------------------------------------------------------------------
wait   # wait for backgrounded sub-containers to terminate
#------------------------------------------------------------------------------------------------------------------------------
rm -f ${InstanceQuitFile}  # global quit signal file
rm -f ${NodeFileDir}/*     # remove node files
rmdir ${NodeFileDir}       # directory should now be empty, remove it
EOJ
printf "\n\nord_soumet ${ContainerJob} -t ${wall} -mpi -cpus ${cpus}x1 -jn ${name} -shell nologin ${queue} $@\n\n\n" 1>&2
if [[ -n $submit ]] ; then
  ord_soumet ${ContainerJob} -t ${wall} -mpi -cpus ${cpus}x1 -jn ${name} -shell nologin ${queue} "$@"
else
  cat ${ContainerJob}
fi
rm -f ${ContainerJob}
